# Relaciones entre modelos

Empecemos por â€œmolestarâ€ a Prisma tomando el control de nuestra base de datos de forma manual.

Voy a crear un campo directamente con una consulta de SQL:

```sql
ALTER TABLE User ADD gender VARCHAR;
```

Prisma te facilita la sincronizaciÃ³n â€œbajandoâ€ el nuevo esquema:

```bash
npx prisma db pull
```

Â¡FÃ­jate en `prisma/shecma.prisma`!

Se ha actualizado con el cambio. ğŸ’¥

### AÃ±adiendo otro modelo

ğŸ› AÃ±ade en el fichero del `schema` lo siguiente:

```ts
model Post {
  id         Int        @id @default(autoincrement())
  createdAt  DateTime   @default(now())
  title      String
  published  Boolean    @default(false)
  author     User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId   Int
}
```

Muchas cosas las conocemos de lo anterior, pero se han aÃ±adido algunas nuevas en la sintaxis:


- `author` es un campo relacionado con el modelo "User". Se define con la directiva `@relation` para indicar que estÃ¡ relacionado con el campo `authorId` del modelo "Post". AdemÃ¡s, se define con la directiva `references` para indicar que se relaciona con el campo `id` del modelo "User". Finalmente, se define con la directiva `onDelete: Cascade` para indicar que cuando se elimina un usuario, se eliminan automÃ¡ticamente todos los posts asociados con ese usuario.
- `authorId` es un campo numÃ©rico que contiene el ID del autor del post. Se define como un campo separado en lugar de como una relaciÃ³n para permitir consultas mÃ¡s eficientes.

ğŸ‘€ `author` no estarÃ¡ representado en la base de datos, pero si es necesario para Prisma para saber la relaciÃ³n entre modelos.


  
ğŸ›  Ahora le diremos a `User` que tiene una relaciÃ³n one-to-many con `Posts`

FÃ­jate que se queja el editor en la lÃ­nea de la `@relation`.

PodrÃ­amos aÃ±adir esta lÃ­nea al final del `model User`

```ts
  Post     Post[]
```

Pero tambiÃ©n podemos dejarle el trabajo a Prisma con:

```ts
npx prisma format
```

Â¡Listo! ğŸ’ª

Es momento de sincronizar con la base de datos:

```bash
npx prisma db push
```


### AÃ±adimos contenido

Vuelve a `script.ts` y coloca este cÃ³digo en `main()`:

```ts
  const posts = [
    {
      title: "Hola Mundo",
      authorId: 1,
    },
    {
      title: "El prÃ³ximo proyecto, con Prisma",
      authorId: 1,
    },
    {
      title: "Esto no lo sabe ni ChatGPT",
      authorId: 2,
    },
    {
      title: "Me lo dices o me lo cuentas",
      authorId: 2,
      published: true,
    },
  ];

  posts.map(async (item) => {
    await prisma.post.create({ data: item })
  });
```

ğŸ‘€ Lanza de nuevo `npx prisma studio` y fÃ­jate en lo que tienes por allÃ­.


## ğŸ’¦ Para que lo resuelvas tÃº

### Consulta con relaciones

ğŸŒ La [documentaciÃ³n](https://www.prisma.io/docs/concepts/components/prisma-client/relation-queries) te ayudarÃ¡ ;)

ğŸ‘€ Nosotros hemos llamado `Post` al campo de relaciÃ³n de `User` con `Post` y en la documentaciÃ³n no lo hace asÃ­.

1) Intenta hacer una consulta desde el cÃ³digo en `script.ts` que consiga:
- Dame todos los usuarios con los posts relacionados

2) Y ahora aÃ±Ã¡dele
- Solo los `Post` que estÃ©n `published == true`

3) Por Ãºltimo, elimina la condiciÃ³n anterior y consigue el nÃºmero de `Post` de cada `User` en una sola consulta


<details>
<summary>~SoluciÃ³n 1~</summary>

```typescript
  const publishedAuthors = await prisma.user.findMany({
    include: {
      Post: true
    },
  });

  console.dir(publishedAuthors, { depth: Infinity });
```

</details>



<details>
<summary>~SoluciÃ³n 2~</summary>

```typescript
  const publishedAuthors = await prisma.user.findMany({
    include: {
      Post: {
        where: {
          published: true
        }
      }
    },
  });

  console.dir(publishedAuthors, { depth: Infinity });
```

</details>



<details>
<summary>~SoluciÃ³n 3~</summary>

```typescript
  const publishedAuthors = await prisma.user.findMany({
    include: {
      _count: {
        select: { Post: true },
      },
    }
  });

  console.dir(publishedAuthors, { depth: Infinity });
```

</details>





ğŸ Â¡Go go go!
